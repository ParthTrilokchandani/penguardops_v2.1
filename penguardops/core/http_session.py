"""
HTTP Session Manager
Handles requests, WAF detection, bypass techniques, and baseline comparison.
"""

import time
import random
import hashlib
import re
from typing import Optional, Dict, Tuple, List
from urllib.parse import urlparse, urljoin

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import urllib3

from core.config import ScanConfig
from utils.logger import get_logger

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
logger = get_logger("http")

# WAF signatures: {waf_name: [header/body patterns]}
WAF_SIGNATURES = {
    "Cloudflare": [
        r"cloudflare", r"cf-ray", r"__cfduid", r"cf_clearance",
        r"Attention Required! \| Cloudflare"
    ],
    "AWS WAF": [
        r"x-amzn-requestid", r"x-amz-cf-id", r"AWS WAF"
    ],
    "Akamai": [
        r"akamai", r"akamaierror", r"x-check-cacheable"
    ],
    "ModSecurity": [
        r"mod_security", r"modsecurity", r"NOYB"
    ],
    "Imperva": [
        r"x-iinfo", r"incapsula", r"visid_incap", r"Incapsula incident"
    ],
    "F5 BIG-IP ASM": [
        r"bigip", r"TS[a-zA-Z0-9]{8}", r"F5 Networks"
    ],
    "Barracuda": [
        r"barracuda", r"barra_counter_session"
    ],
    "Sucuri": [
        r"sucuri", r"x-sucuri-id", r"Access Denied - Sucuri Website Firewall"
    ],
    "Wordfence": [
        r"wordfence", r"generated by wordfence"
    ],
    "Generic WAF": [
        r"403 Forbidden", r"Access Denied", r"blocked", r"security violation"
    ],
}

WAF_BYPASS_TECHNIQUES = {
    "case_variation": lambda p: p.upper() if random.random() > 0.5 else p.lower(),
    "comment_insertion": lambda p: p.replace("SELECT", "SE/**/LECT").replace("UNION", "UN/**/ION"),
    "url_encoding": lambda p: p.replace("'", "%27").replace('"', "%22").replace(" ", "%20"),
    "double_encoding": lambda p: p.replace("%", "%25"),
    "whitespace_variation": lambda p: p.replace(" ", "\t").replace(" ", "\n"),
}


class BaselineResponse:
    """Stores baseline response characteristics for comparison."""

    def __init__(self, response: requests.Response):
        self.status_code = response.status_code
        self.content_length = len(response.content)
        self.content_hash = hashlib.md5(response.content).hexdigest()
        self.headers = dict(response.headers)
        self.content_type = response.headers.get("Content-Type", "")
        self.title = self._extract_title(response.text)
        self.error_indicators = self._check_errors(response.text)

    def _extract_title(self, html: str) -> str:
        match = re.search(r"<title[^>]*>(.*?)</title>", html, re.IGNORECASE | re.DOTALL)
        return match.group(1).strip() if match else ""

    def _check_errors(self, html: str) -> List[str]:
        error_patterns = [
            r"mysql_fetch", r"ORA-\d+", r"Microsoft OLE DB",
            r"syntax error", r"Uncaught Exception", r"Fatal error",
            r"Warning:", r"Notice:", r"pg_query"
        ]
        found = []
        for pat in error_patterns:
            if re.search(pat, html, re.IGNORECASE):
                found.append(pat)
        return found

    def differs_from(self, other: "BaselineResponse", threshold: float = 0.2) -> bool:
        """Check if another response significantly differs from baseline."""
        if other.status_code != self.status_code:
            return True
        if self.content_length > 0:
            diff_ratio = abs(other.content_length - self.content_length) / self.content_length
            if diff_ratio > threshold:
                return True
        if other.title != self.title:
            return True
        return False


class HttpSession:
    """
    Managed HTTP session with WAF detection, bypass, and request tracking.
    """

    def __init__(self, config: ScanConfig):
        self.config = config
        self.session = self._build_session()
        self.request_count = 0
        self.waf_detected: Optional[str] = None
        self.waf_checked = False
        self._baselines: Dict[str, BaselineResponse] = {}

    def _build_session(self) -> requests.Session:
        session = requests.Session()

        # Retry strategy
        retry = Retry(
            total=2,
            backoff_factor=0.5,
            status_forcelist=[500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry)
        session.mount("http://", adapter)
        session.mount("https://", adapter)

        # Headers
        session.headers.update({
            "User-Agent": self.config.user_agent,
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive",
        })
        if self.config.custom_headers:
            session.headers.update(self.config.custom_headers)

        # Cookies
        if self.config.cookies:
            session.cookies.update(self.config.cookies)

        # Auth
        if self.config.auth_user and self.config.auth_pass:
            session.auth = (self.config.auth_user, self.config.auth_pass)

        # Proxy
        if self.config.proxy:
            session.proxies = {"http": self.config.proxy, "https": self.config.proxy}

        return session

    def get(self, url: str, **kwargs) -> Optional[requests.Response]:
        return self._request("GET", url, **kwargs)

    def post(self, url: str, data=None, **kwargs) -> Optional[requests.Response]:
        return self._request("POST", url, data=data, **kwargs)

    def _request(self, method: str, url: str, **kwargs) -> Optional[requests.Response]:
        kwargs.setdefault("timeout", self.config.timeout)
        kwargs.setdefault("verify", self.config.verify_ssl)
        kwargs.setdefault("allow_redirects", True)

        try:
            if self.config.delay > 0:
                # Jitter to avoid rate limiting
                jitter = random.uniform(0, self.config.delay * 0.5)
                time.sleep(self.config.delay + jitter)

            resp = self.session.request(method, url, **kwargs)
            self.request_count += 1

            if self.config.verbose:
                logger.debug(f"{method} {url} → {resp.status_code} ({len(resp.content)}b)")

            return resp

        except requests.exceptions.Timeout:
            logger.warning(f"Timeout: {url}")
        except requests.exceptions.ConnectionError:
            logger.warning(f"Connection error: {url}")
        except requests.exceptions.TooManyRedirects:
            logger.warning(f"Too many redirects: {url}")
        except Exception as e:
            logger.debug(f"Request error {url}: {e}")

        return None

    def detect_waf(self, url: str) -> Optional[str]:
        """Detect WAF by sending a benign probe and analyzing response headers/body."""
        if self.waf_checked:
            return self.waf_detected

        self.waf_checked = True
        probe_url = url.rstrip("/") + "/?vulnscan_waf_probe=<script>alert(1)</script>"

        try:
            resp = self.get(probe_url)
            if not resp:
                return None

            check_text = (
                " ".join(f"{k}: {v}" for k, v in resp.headers.items())
                + " " + resp.text[:2000]
            ).lower()

            for waf_name, patterns in WAF_SIGNATURES.items():
                for pattern in patterns:
                    if re.search(pattern.lower(), check_text):
                        self.waf_detected = waf_name
                        logger.info(f"WAF detected: {waf_name}")
                        return waf_name

        except Exception:
            pass

        logger.info("No WAF detected")
        return None

    def apply_waf_bypass(self, payload: str, technique: str = "random") -> str:
        """Apply WAF bypass transformation to payload."""
        if not self.config.waf_bypass:
            return payload

        if technique == "random":
            technique = random.choice(list(WAF_BYPASS_TECHNIQUES.keys()))

        bypass_fn = WAF_BYPASS_TECHNIQUES.get(technique)
        if bypass_fn:
            return bypass_fn(payload)
        return payload

    def get_baseline(self, url: str) -> Optional[BaselineResponse]:
        """Get or create baseline response for URL."""
        if url in self._baselines:
            return self._baselines[url]

        resp = self.get(url)
        if resp:
            baseline = BaselineResponse(resp)
            self._baselines[url] = baseline
            return baseline
        return None

    def response_differs_from_baseline(
        self,
        url: str,
        response: requests.Response,
        threshold: float = 0.2
    ) -> bool:
        """Compare response against baseline — used to reduce false positives."""
        baseline = self.get_baseline(url)
        if not baseline:
            return False

        current = BaselineResponse(response)
        return baseline.differs_from(current, threshold)
